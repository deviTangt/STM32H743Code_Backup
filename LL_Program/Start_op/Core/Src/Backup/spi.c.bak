/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * @file    spi.c
  * @brief   This file provides code for the configuration
  *          of the SPI instances.
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2025 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */
/* USER CODE END Header */
/* Includes ------------------------------------------------------------------*/
#include "spi.h"

/* USER CODE BEGIN 0 */

/* USER CODE END 0 */

/* SPI6 init function */
void MX_SPI6_Init(void)
{

  /* USER CODE BEGIN SPI6_Init 0 */

  /* USER CODE END SPI6_Init 0 */

  LL_SPI_InitTypeDef SPI_InitStruct = {0};

  LL_GPIO_InitTypeDef GPIO_InitStruct = {0};

  LL_RCC_SetSPIClockSource(LL_RCC_SPI6_CLKSOURCE_PCLK4);

  /* Peripheral clock enable */
  LL_APB4_GRP1_EnableClock(LL_APB4_GRP1_PERIPH_SPI6);

  LL_AHB4_GRP1_EnableClock(LL_AHB4_GRP1_PERIPH_GPIOA);
  LL_AHB4_GRP1_EnableClock(LL_AHB4_GRP1_PERIPH_GPIOB);
  /**SPI6 GPIO Configuration
  PA7   ------> SPI6_MOSI
  PB3 (JTDO/TRACESWO)   ------> SPI6_SCK
  */
  GPIO_InitStruct.Pin = TFTLCD_SDA_Pin;
  GPIO_InitStruct.Mode = LL_GPIO_MODE_ALTERNATE;
  GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_HIGH;
  GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;
  GPIO_InitStruct.Pull = LL_GPIO_PULL_UP;
  GPIO_InitStruct.Alternate = LL_GPIO_AF_8;
  LL_GPIO_Init(TFTLCD_SDA_GPIO_Port, &GPIO_InitStruct);

  GPIO_InitStruct.Pin = TFTLCD_SCL_Pin;
  GPIO_InitStruct.Mode = LL_GPIO_MODE_ALTERNATE;
  GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_HIGH;
  GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;
  GPIO_InitStruct.Pull = LL_GPIO_PULL_UP;
  GPIO_InitStruct.Alternate = LL_GPIO_AF_8;
  LL_GPIO_Init(TFTLCD_SCL_GPIO_Port, &GPIO_InitStruct);

  /* USER CODE BEGIN SPI6_Init 1 */

  /* USER CODE END SPI6_Init 1 */
  SPI_InitStruct.TransferDirection = LL_SPI_SIMPLEX_TX;
  SPI_InitStruct.Mode = LL_SPI_MODE_MASTER;
  SPI_InitStruct.DataWidth = LL_SPI_DATAWIDTH_8BIT;
  SPI_InitStruct.ClockPolarity = LL_SPI_POLARITY_HIGH;
  SPI_InitStruct.ClockPhase = LL_SPI_PHASE_2EDGE;
  SPI_InitStruct.NSS = LL_SPI_NSS_SOFT;
  SPI_InitStruct.BaudRate = LL_SPI_BAUDRATEPRESCALER_DIV32;
  SPI_InitStruct.BitOrder = LL_SPI_MSB_FIRST;
  SPI_InitStruct.CRCCalculation = LL_SPI_CRCCALCULATION_DISABLE;
  SPI_InitStruct.CRCPoly = 0x0;
  LL_SPI_Init(SPI6, &SPI_InitStruct);
  LL_SPI_SetStandard(SPI6, LL_SPI_PROTOCOL_MOTOROLA);
  LL_SPI_SetFIFOThreshold(SPI6, LL_SPI_FIFO_TH_01DATA);
  LL_SPI_EnableNSSPulseMgt(SPI6);
  /* USER CODE BEGIN SPI6_Init 2 */

  LL_SPI_Enable(SPI6);
  
  /* USER CODE END SPI6_Init 2 */

}

/* USER CODE BEGIN 1 */
void LCD_SPI_SendBytes(const uint8_t* data){
  static uint32_t spi_cnt = 0;
  printf_s(23, "spi_cnt:%d", ++spi_cnt);
  //printf_s(20, "min:%3d sec:%02d.%03d us:%03d\r\n", bsp_min, bsp_sec % 60, bsp_ms % 1000, bsp_us % 1000);


  #define SPI_DEBUG 0
  #if SPI_DEBUG
    printf_s(1, "TXC:%1d        CSTART:%1d", LL_SPI_IsActiveFlag_TXC(SPI6), LL_I2S_IsActiveTransfer(SPI6));
    printf_s(2, "EOT:%1d        TXP:%1d", LL_SPI_IsActiveFlag_EOT(SPI6), LL_SPI_IsActiveFlag_TXP(SPI6));
#endif
uint32_t cnt = 0;
while (LL_I2S_IsActiveTransfer(SPI6) == SET){
  printf_s(20, "min:%3d sec:%02d.%03d us:%03d\r\n", bsp_min, bsp_sec % 60, bsp_ms % 1000, bsp_us % 1000);
  #if SPI_DEBUG
  printf_s(11, "TXC:%1d        CSTART:%1d", LL_SPI_IsActiveFlag_TXC(SPI6), LL_I2S_IsActiveTransfer(SPI6));
  printf_s(12, "EOT:%1d        TXP:%1d    cnt:%d", LL_SPI_IsActiveFlag_EOT(SPI6), LL_SPI_IsActiveFlag_TXP(SPI6)), cnt++;
  #endif
};
    LL_SPI_Enable(SPI6);
    LL_SPI_SetHalfDuplexDirection(SPI6, LL_SPI_HALF_DUPLEX_TX);
    LL_SPI_SetTransferSize(SPI6, 1);
    LL_SPI_StartMasterTransfer(SPI6);

    #if SPI_DEBUG
    printf_s(5, "TXC:%1d        CSTART:%1d", LL_SPI_IsActiveFlag_TXC(SPI6), LL_I2S_IsActiveTransfer(SPI6));
    printf_s(6, "EOT:%1d        TXP:%1d", LL_SPI_IsActiveFlag_EOT(SPI6), LL_SPI_IsActiveFlag_TXP(SPI6));
#endif

    while (1)
    {
        if (LL_SPI_IsActiveFlag_TXP(SPI6))
        {
            LL_SPI_TransmitData8(SPI6, *((const uint8_t *)data));
            data += sizeof(uint8_t);
            break;
        }
    }

    #if SPI_DEBUG
    printf_s(15, "TXC:%1d        CSTART:%1d", LL_SPI_IsActiveFlag_TXC(SPI6), LL_I2S_IsActiveTransfer(SPI6));
    printf_s(16, "EOT:%1d        TXP:%1d", LL_SPI_IsActiveFlag_EOT(SPI6), LL_SPI_IsActiveFlag_TXP(SPI6));
    #endif

    LL_SPI_Disable(SPI6);
}

/* USER CODE END 1 */
